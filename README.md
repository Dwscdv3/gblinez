# gblinez

Yet another Color Lines game. For Game Boy.

This replica features the same gameplay as the original version, with smooth animation.

## How to Play

There is plenty of resources over the Internet, just [Google the original title](https://www.google.com/search?q=color+lines+gameplay).

## Key Bindings

| Key   | Function                                         |
|-------|--------------------------------------------------|
| D-Pad | Navigate the cursor                              |
| A     | Select, or move the selected stone to the cursor |
| B     | Hold for auto-repeating D-Pad (rapid mode)       |
| Start | Restart the game                                 |

## What's Next?

This would be the final release if nobody is interested in this project. I have currently no plan for implementing more features such as sound effects or high scores.

## For Fellow Developers

You may find a bunch of useful libraries in the `src/dwlib80/` directory.

Many of the functions are properly documented, you can use the VS Code extension [RGBDS Z80](https://marketplace.visualstudio.com/items?itemName=donaldhays.rgbds-z80) for hovering documents.

Members start with a `_` is considered private, they are not meant to be used by end users.

### memory.asm

A must have for every program beyond "Hello, world!".

* `memset`
* `memcpy`
* `reverse`
* macro `read` - A one-liner for reading memory into any register.
* macro `write` - A one-liner for writing any register into memory.
* macro `readh` - Same as above, but optimized with `ldh` instruction.
* macro `writeh` - Same as above, but optimized with `ldh` instruction.

### math.asm

Nothing here. No trigonometric functions, floating-point arithmetics, nor even integer multiplying. Don't expect this as something like `math.h` in C.

* `Divide` - 8-bit general division algorithm.
* `ToDecimal8` - 8-bit BCD.
* macro `AddR16D8` - A handy macro for adding 8-bit immediate values to any register pair (using carry flag, not HL register).

### rand.asm

For best performance, random numbers are not generated by RNG algorithms but rely on a 256 bytes long circular table and entropy provided by user input. To make the RNG unbiased another bias check table is used.

You should call macro `SeedRandom` in your joypad interrupt handler to collect entropy.

### animation.asm

Linear animation, with arguments of delta X, delta Y, and duration in frames.

The current implementation will block the execution until the animation is ended.

### pathfinding.asm

A standard (?) BFS algorithm.

* 512 bytes used for buffer.
* Requirements for a compatible gameboard:
  * Should be a `byte[]` array.
  * Less than 256 bytes.
  * Value 0 is passable, otherwise obstacles.

After a successful search, `Pathfinding_backtrace` is filled with a unidirectional linked list, from search target to search origin. If you want the reverse path, simply exchange the origin argument with the target argument.

### controlflow.asm

An elegant way to write counter loops.

Search `BeginLoop` in this repository for example.

### oam.asm

All the OAM and DMA stuff goes here.

Sprites related functions are organized to 8x8, 8x16, 8x8x4, 8x16x2. Currently, only 8x16x2 functions are implemented.

* `OAMBuffer` - Don't allocate it twice, just use this for your game.
* `ClearOAMBuffer`
* `SetSprite` - Give a sprite a tile.
* `SetSpritePos`
* `HideSprite` - Technically just set its Y pos to 0.
* `InitDMA` - Copy DMA waiting routine to HRAM.
* `StartDMA`

### input.asm

An input handler, with keypress support (only trigger once until pressed that key again).

Call `Input` from your game loop, then read `JoypadState` or `PressedKeys`.
